hs = [1,2,3,4,5,6]
names = [portal,gate];

IDEAS:
    The main idea is the ability to instatiate new chatting rooms,
    that do not last for long and dont keep track of the conversation.
    The maximun time thay can be availabe is 24 hrs or they get deleted
    as soon as everyone leaves the room.
    
----------------------------Architecture------------------------------

    nginx=
    world <=> Nginx <=> Rest api <=> rooms

    
     ---------        ----------      -------
     | nginx |   <=>  |rest api|  <=> |rooms|
     ---------        ----------      -------
    
    
----------------------------------------------------------------------
Api Documentation:
-----------------------------REST API--------------------------------cd
    This cant be socket related stuff, this commands are to get general
    information at a given time, they cant me used to send messages, files,
    or anything within exinsting chats, this would lose the inmediate 
    feedback chats need.
    They will be used for : Creating new chats
                            Getting information from existing chats
                            Setting up desired behaviours
                            Terminating chats
                            Configuaration
                            Editing
                            
    ENDPOINTS:
    GET api/v1/<room_id> | <room_name>
        Description:
            Responds with object containing all the details about 
            <room_id>, that is name,id,connections, data volume?,
                     date, time alive,expiration date


    POST api/v1/room creates new socket (chat) linked to command (2)
        Description:
            Launches a new room cotainer, which conatains the room
            running server.

        Request params:
       -name <name>  : name for the chat room
       -max <max_number> : maximum number of connection allowed
       -expiration_date <hours_to_end | usersLeave> max = 24
                    <usersLeave> => room gets removed when all users leave 

        Responds: 

            Responds with the details/credentials to connect to it.
                name : <room_name>
                expiration : <room_expiration>
                owner_id : <owner_id>
                invite_key : <key other users will use to connect to the room>
                chat: ws://domain.name/<room_id>

-----------------------------END REST API-----------------------------

-----------------------------CLI TOOL---------------------------------
// cli tool? allow developers to test stuff faster 
[] command base : 
        command help => gives list and description of all commands availables
        send -f <path_to_file> command for sending files
        (2) => create room <room_id> : command for creating a new chat room
               -name <name>  : name for the chat room
               -max <max_number> : maximum number of connection allowed
        (3) => get room <room_id | room_name>
                    Responds with object containing all the details about 
                    <room_id>, that is name,id,connections, data volume?,
                             date, time alive,expiration date
-----------------------------END CLI TOOL------------------------------

---------------------------------DEV-----------------------------------
     
--------------------------------END DEV--------------------------------

Research:
    [] api security => keys,etc
    [] cron jobs
    [] uxix sockets
    [] multi threading
    [] The max amount of stablished websocet connections a server can handle are    
        related to the number of file descriptors availabe on the host machine

PROBLEMS:
    Thougths:
        I just realized that making a single WebSocket server for each client   
        is totally retarded.
            we only have 65k available ports on each machine - system reserved ports!
            that would never work.
            Tho we can have thousands of connections to a single websocket server,
            each time a client makes a POST to "create a new room" we just reserve
            a subset of connections within that webSocket server and we identify it
            with some hashing.

        An in memory-database might be needed, redis?
        
    Users can chat with one another and create chat groups, both features are short-lived,
    and only accesible with a certain key, and password if the creator wants it.

    ROOMS :
        id : <string> uuid
        host: <String>
        name : <string>
        url : <string> http://hostname/roomid
        pwd : <string>
        expires: <number> hrs - example : 24hs
        availabe: <string> : indicates when room should be availabe for users to join 


    POST api/v1/room => Endpoint will reserve N amount of spots for each user.
        user must be able to connect from multiple clients!
        so, suppose there are 18 connected users on room A, and user number 2, decides to 
        open 3 extra chrome tabs and connect to the room from each one of them, now, should
        this three new connections count as new connections to the room? short answer, NO.
        Users stablishing new connections from different clients whule still being already connected
        to the server is a pretty common scenario.
        Internally the server should interpret this extra connections as a single user being connected,
        and handle iddle connections, possibly terminating them for resource optimizations,
        this wont cause any loss of user experience, after all the user can always connect again,
        nevertheless this should be handle accordingly.

        Stores room information on database.

        rooms will remain alive until host decide to delete it or AliveFor expires.
        Rooms will be identified with a uuid, atatched to that uuid, there will be some structure
        containing the remaining information for that room. 
        
        TODO:
                room = room_name+user_id?random_string
                [] sing up user
                [] integrate user information at the time of creating new rooms.
                
        
    UPDATE api/v1/room/keepAlive :
        if sent before room expires string, expires value will be incremented to keep alive the room.

    DELETE api/v1/room
        Deletes room.
        Removes all its data from database.
    
        HOW TO ID USERS?
            Only room hosts should signed in.

            Since the main objective is that everything is as fast as possible, what do i mean
            by this?.
            you can get a link, a that should be it, you should be able to share that link around
            and start chatting.
            So an actual signing up should by no means be required to use the app, even thougt it should
            be available, maybe for some user-reserved features?
            Signing up takes time, and that is the oppsite of what the main goal of the app is trying to
            achieve.
            So, if the user is not signed up, a different mechanisim for identifying users will be needed.
            we could try to id its remoteAdress, or maybe send some token, identifying signed users 
            should not be a problem at all, since we can use that users information..

    WebSocket server resources concerns:
        

    
